// lib/main.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:studypals/providers/app_state.dart';
import 'package:studypals/screens/dashboard_screen.dart';
import 'package:studypals/screens/auth/login_screen.dart';
import 'package:studypals/theme/app_theme.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  // Initialize databases and services here
  runApp(StudyPalsApp());
}

class StudyPalsApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => AppState()),
        ChangeNotifierProvider(create: (_) => TaskProvider()),
        ChangeNotifierProvider(create: (_) => NoteProvider()),
        ChangeNotifierProvider(create: (_) => DeckProvider()),
        ChangeNotifierProvider(create: (_) => PetProvider()),
        ChangeNotifierProvider(create: (_) => SRSProvider()),
      ],
      child: MaterialApp(
        title: 'StudyPals',
        theme: AppTheme.lightTheme,
        darkTheme: AppTheme.darkTheme,
        home: AuthWrapper(),
      ),
    );
  }
}

// lib/models/task.dart
class Task {
  final String id;
  final String title;
  final int estMinutes;
  final DateTime? dueAt;
  final int priority;
  final List<String> tags;
  final TaskStatus status;
  final String? linkedNoteId;
  final String? linkedDeckId;

  Task({
    required this.id,
    required this.title,
    required this.estMinutes,
    this.dueAt,
    this.priority = 1,
    this.tags = const [],
    this.status = TaskStatus.pending,
    this.linkedNoteId,
    this.linkedDeckId,
  });

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'estMinutes': estMinutes,
    'dueAt': dueAt?.toIso8601String(),
    'priority': priority,
    'tags': tags,
    'status': status.toString(),
    'linkedNoteId': linkedNoteId,
    'linkedDeckId': linkedDeckId,
  };

  factory Task.fromJson(Map<String, dynamic> json) => Task(
    id: json['id'],
    title: json['title'],
    estMinutes: json['estMinutes'],
    dueAt: json['dueAt'] != null ? DateTime.parse(json['dueAt']) : null,
    priority: json['priority'] ?? 1,
    tags: List<String>.from(json['tags'] ?? []),
    status: TaskStatus.values.firstWhere(
      (e) => e.toString() == json['status'],
      orElse: () => TaskStatus.pending,
    ),
    linkedNoteId: json['linkedNoteId'],
    linkedDeckId: json['linkedDeckId'],
  );
}

enum TaskStatus { pending, inProgress, completed, cancelled }

// lib/models/note.dart
class Note {
  final String id;
  final String title;
  final String contentMd;
  final List<String> tags;
  final DateTime createdAt;
  final DateTime updatedAt;

  Note({
    required this.id,
    required this.title,
    required this.contentMd,
    this.tags = const [],
    DateTime? createdAt,
    DateTime? updatedAt,
  }) : createdAt = createdAt ?? DateTime.now(),
        updatedAt = updatedAt ?? DateTime.now();

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'contentMd': contentMd,
    'tags': tags,
    'createdAt': createdAt.toIso8601String(),
    'updatedAt': updatedAt.toIso8601String(),
  };

  factory Note.fromJson(Map<String, dynamic> json) => Note(
    id: json['id'],
    title: json['title'],
    contentMd: json['contentMd'],
    tags: List<String>.from(json['tags'] ?? []),
    createdAt: DateTime.parse(json['createdAt']),
    updatedAt: DateTime.parse(json['updatedAt']),
  );
}

// lib/models/card.dart
class FlashCard {
  final String id;
  final String deckId;
  final CardType type;
  final String front;
  final String back;
  final String? clozeMask;

  FlashCard({
    required this.id,
    required this.deckId,
    required this.type,
    required this.front,
    required this.back,
    this.clozeMask,
  });

  Map<String, dynamic> toJson() => {
    'id': id,
    'deckId': deckId,
    'type': type.toString(),
    'front': front,
    'back': back,
    'clozeMask': clozeMask,
  };

  factory FlashCard.fromJson(Map<String, dynamic> json) => FlashCard(
    id: json['id'],
    deckId: json['deckId'],
    type: CardType.values.firstWhere(
      (e) => e.toString() == json['type'],
      orElse: () => CardType.basic,
    ),
    front: json['front'],
    back: json['back'],
    clozeMask: json['clozeMask'],
  );
}

enum CardType { basic, cloze, reverse }

// lib/models/deck.dart
class Deck {
  final String id;
  final String title;
  final List<String> tags;
  final String? noteId;
  final List<FlashCard> cards;

  Deck({
    required this.id,
    required this.title,
    this.tags = const [],
    this.noteId,
    this.cards = const [],
  });
}

// lib/models/review.dart
class Review {
  final String cardId;
  final String userId;
  final DateTime dueAt;
  final double ease;
  final int interval;
  final int reps;
  final ReviewGrade? lastGrade;

  Review({
    required this.cardId,
    required this.userId,
    required this.dueAt,
    this.ease = 2.5,
    this.interval = 1,
    this.reps = 0,
    this.lastGrade,
  });

  Review updateWithGrade(ReviewGrade grade) {
    // SM-2 algorithm implementation
    double newEase = ease;
    int newInterval = interval;
    int newReps = reps + 1;

    switch (grade) {
      case ReviewGrade.again:
        newReps = 0;
        newInterval = 1;
        newEase = ease - 0.2;
        break;
      case ReviewGrade.hard:
        newInterval = (interval * 1.2).round();
        newEase = ease - 0.15;
        break;
      case ReviewGrade.good:
        if (reps == 0) {
          newInterval = 1;
        } else if (reps == 1) {
          newInterval = 6;
        } else {
          newInterval = (interval * ease).round();
        }
        break;
      case ReviewGrade.easy:
        newInterval = (interval * ease * 1.3).round();
        newEase = ease + 0.15;
        break;
    }

    newEase = newEase.clamp(1.3, 2.5);

    return Review(
      cardId: cardId,
      userId: userId,
      dueAt: DateTime.now().add(Duration(days: newInterval)),
      ease: newEase,
      interval: newInterval,
      reps: newReps,
      lastGrade: grade,
    );
  }
}

enum ReviewGrade { again, hard, good, easy }

// lib/models/pet.dart
class Pet {
  final String userId;
  final PetSpecies species;
  final int level;
  final int xp;
  final List<String> gear;
  final PetMood mood;

  Pet({
    required this.userId,
    required this.species,
    this.level = 1,
    this.xp = 0,
    this.gear = const [],
    this.mood = PetMood.happy,
  });

  int get xpForNextLevel => level * 100;
  double get xpProgress => xp / xpForNextLevel;

  Pet addXP(int amount) {
    int newXP = xp + amount;
    int newLevel = level;
    
    while (newXP >= newLevel * 100) {
      newXP -= newLevel * 100;
      newLevel++;
    }

    return Pet(
      userId: userId,
      species: species,
      level: newLevel,
      xp: newXP,
      gear: gear,
      mood: _calculateMood(newLevel, newXP),
    );
  }

  PetMood _calculateMood(int level, int xp) {
    // Logic for pet mood based on progress
    if (xp > level * 80) return PetMood.excited;
    if (xp > level * 50) return PetMood.happy;
    if (xp > level * 20) return PetMood.content;
    return PetMood.sleepy;
  }
}

enum PetSpecies { cat, dog, dragon, owl, fox }
enum PetMood { sleepy, content, happy, excited }

// lib/screens/dashboard_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:studypals/widgets/dashboard/today_view.dart';
import 'package:studypals/widgets/dashboard/pet_widget.dart';
import 'package:studypals/widgets/dashboard/progress_widget.dart';

class DashboardScreen extends StatefulWidget {
  @override
  _DashboardScreenState createState() => _DashboardScreenState();
}

class _DashboardScreenState extends State<DashboardScreen> {
  int _selectedIndex = 0;

  final List<Widget> _pages = [
    DashboardHome(),
    PlannerScreen(),
    NotesScreen(),
    DecksScreen(),
    ProgressScreen(),
  ];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: _pages[_selectedIndex],
      bottomNavigationBar: NavigationBar(
        selectedIndex: _selectedIndex,
        onDestinationSelected: (index) {
          setState(() {
            _selectedIndex = index;
          });
        },
        destinations: [
          NavigationDestination(
            icon: Icon(Icons.dashboard),
            label: 'Dashboard',
          ),
          NavigationDestination(
            icon: Icon(Icons.calendar_today),
            label: 'Planner',
          ),
          NavigationDestination(
            icon: Icon(Icons.note),
            label: 'Notes',
          ),
          NavigationDestination(
            icon: Icon(Icons.style),
            label: 'Decks',
          ),
          NavigationDestination(
            icon: Icon(Icons.insights),
            label: 'Progress',
          ),
        ],
      ),
    );
  }
}

class DashboardHome extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Today'),
        actions: [
          IconButton(
            icon: Icon(Icons.notifications),
            onPressed: () {},
          ),
          IconButton(
            icon: Icon(Icons.settings),
            onPressed: () {},
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            PetWidget(),
            SizedBox(height: 20),
            TodayTasksWidget(),
            SizedBox(height: 20),
            DueCardsWidget(),
            SizedBox(height: 20),
            QuickStatsWidget(),
          ],
        ),
      ),
    );
  }
}

// lib/widgets/dashboard/pet_widget.dart
class PetWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Consumer<PetProvider>(
      builder: (context, petProvider, child) {
        final pet = petProvider.currentPet;
        
        return Card(
          elevation: 4,
          child: Padding(
            padding: EdgeInsets.all(16),
            child: Column(
              children: [
                Row(
                  children: [
                    // Pet Avatar
                    Container(
                      width: 80,
                      height: 80,
                      decoration: BoxDecoration(
                        shape: BoxShape.circle,
                        color: Theme.of(context).primaryColor.withOpacity(0.1),
                      ),
                      child: Center(
                        child: _getPetIcon(pet.species),
                      ),
                    ),
                    SizedBox(width: 16),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            'Level ${pet.level} ${pet.species.name}',
                            style: Theme.of(context).textTheme.titleMedium,
                          ),
                          SizedBox(height: 8),
                          LinearProgressIndicator(
                            value: pet.xpProgress,
                            backgroundColor: Colors.grey[300],
                            valueColor: AlwaysStoppedAnimation<Color>(
                              _getMoodColor(pet.mood),
                            ),
                          ),
                          SizedBox(height: 4),
                          Text(
                            '${pet.xp} / ${pet.xpForNextLevel} XP',
                            style: Theme.of(context).textTheme.bodySmall,
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
                SizedBox(height: 12),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceAround,
                  children: [
                    _buildMoodChip(context, pet.mood),
                    _buildStreakChip(context, petProvider.currentStreak),
                  ],
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _getPetIcon(PetSpecies species) {
    IconData icon;
    switch (species) {
      case PetSpecies.cat:
        icon = Icons.pets;
        break;
      case PetSpecies.dog:
        icon = Icons.pets;
        break;
      case PetSpecies.dragon:
        icon = Icons.whatshot;
        break;
      case PetSpecies.owl:
        icon = Icons.nights_stay;
        break;
      case PetSpecies.fox:
        icon = Icons.nature;
        break;
    }
    return Icon(icon, size: 40);
  }

  Color _getMoodColor(PetMood mood) {
    switch (mood) {
      case PetMood.excited:
        return Colors.green;
      case PetMood.happy:
        return Colors.lightGreen;
      case PetMood.content:
        return Colors.orange;
      case PetMood.sleepy:
        return Colors.grey;
    }
  }

  Widget _buildMoodChip(BuildContext context, PetMood mood) {
    return Chip(
      avatar: Icon(Icons.emoji_emotions, size: 16),
      label: Text(mood.name),
      backgroundColor: _getMoodColor(mood).withOpacity(0.2),
    );
  }

  Widget _buildStreakChip(BuildContext context, int streak) {
    return Chip(
      avatar: Icon(Icons.local_fire_department, size: 16, color: Colors.orange),
      label: Text('$streak day streak'),
      backgroundColor: Colors.orange.withOpacity(0.2),
    );
  }
}

// lib/services/srs_service.dart
class SRSService {
  // SM-2 Algorithm Implementation
  static Review scheduleReview(FlashCard card, ReviewGrade grade, Review? previousReview) {
    if (previousReview == null) {
      // First review
      return Review(
        cardId: card.id,
        userId: '', // Set from auth
        dueAt: _getInitialDueDate(grade),
        ease: 2.5,
        interval: 1,
        reps: 1,
        lastGrade: grade,
      );
    }
    
    return previousReview.updateWithGrade(grade);
  }

  static DateTime _getInitialDueDate(ReviewGrade grade) {
    switch (grade) {
      case ReviewGrade.again:
        return DateTime.now().add(Duration(minutes: 10));
      case ReviewGrade.hard:
        return DateTime.now().add(Duration(days: 1));
      case ReviewGrade.good:
        return DateTime.now().add(Duration(days: 1));
      case ReviewGrade.easy:
        return DateTime.now().add(Duration(days: 3));
    }
  }

  static List<FlashCard> getDueCards(List<Review> reviews, List<FlashCard> allCards) {
    final now = DateTime.now();
    final dueReviews = reviews.where((r) => r.dueAt.isBefore(now)).toList();
    
    return allCards.where((card) => 
      dueReviews.any((review) => review.cardId == card.id)
    ).toList();
  }
}

// lib/services/planner_service.dart
class PlannerService {
  static List<ScheduleBlock> autoSchedule({
    required List<Task> tasks,
    required List<Review> dueReviews,
    required UserPreferences prefs,
  }) {
    List<ScheduleBlock> blocks = [];
    DateTime currentTime = DateTime.now();
    
    // Sort tasks by priority and deadline
    tasks.sort((a, b) {
      if (a.dueAt != null && b.dueAt != null) {
        int dueDateCompare = a.dueAt!.compareTo(b.dueAt!);
        if (dueDateCompare != 0) return dueDateCompare;
      }
      return b.priority.compareTo(a.priority);
    });
    
    // Schedule high-priority tasks first
    for (var task in tasks) {
      if (task.status == TaskStatus.completed) continue;
      
      var block = ScheduleBlock(
        taskId: task.id,
        start: _findNextAvailableSlot(currentTime, task.estMinutes, blocks, prefs),
        duration: Duration(minutes: task.estMinutes),
        type: BlockType.task,
      );
      blocks.add(block);
    }
    
    // Schedule SRS reviews
    int reviewTime = dueReviews.length * 2; // ~2 minutes per card
    if (reviewTime > 0) {
      blocks.add(ScheduleBlock(
        start: _findNextAvailableSlot(currentTime, reviewTime, blocks, prefs),
        duration: Duration(minutes: reviewTime),
        type: BlockType.review,
      ));
    }
    
    return blocks;
  }

  static DateTime _findNextAvailableSlot(
    DateTime from,
    int durationMinutes,
    List<ScheduleBlock> existingBlocks,
    UserPreferences prefs,
  ) {
    // Implementation to find next available time slot
    // considering user's preferred study hours
    DateTime slot = from;
    
    // Check for conflicts and user preferences
    while (_hasConflict(slot, durationMinutes, existingBlocks) ||
           !_isWithinStudyHours(slot, prefs)) {
      slot = slot.add(Duration(minutes: 15));
    }
    
    return slot;
  }

  static bool _hasConflict(DateTime start, int duration, List<ScheduleBlock> blocks) {
    final end = start.add(Duration(minutes: duration));
    
    for (var block in blocks) {
      final blockEnd = block.start.add(block.duration);
      if (start.isBefore(blockEnd) && end.isAfter(block.start)) {
        return true;
      }
    }
    
    return false;
  }

  static bool _isWithinStudyHours(DateTime time, UserPreferences prefs) {
    final hour = time.hour;
    return hour >= prefs.studyStartHour && hour < prefs.studyEndHour;
  }
}

class ScheduleBlock {
  final String? taskId;
  final DateTime start;
  final Duration duration;
  final BlockType type;

  ScheduleBlock({
    this.taskId,
    required this.start,
    required this.duration,
    required this.type,
  });
}

enum BlockType { task, review, break }

class UserPreferences {
  final int studyStartHour;
  final int studyEndHour;
  final int maxCardsPerDay;
  final int maxMinutesPerDay;

  UserPreferences({
    this.studyStartHour = 9,
    this.studyEndHour = 21,
    this.maxCardsPerDay = 20,
    this.maxMinutesPerDay = 180,
  });
}

// lib/providers/app_state.dart
import 'package:flutter/foundation.dart';

class AppState extends ChangeNotifier {
  bool _isAuthenticated = false;
  User? _currentUser;

  bool get isAuthenticated => _isAuthenticated;
  User? get currentUser => _currentUser;

  void login(User user) {
    _currentUser = user;
    _isAuthenticated = true;
    notifyListeners();
  }

  void logout() {
    _currentUser = null;
    _isAuthenticated = false;
    notifyListeners();
  }
}

class TaskProvider extends ChangeNotifier {
  List<Task> _tasks = [];
  List<Task> get tasks => _tasks;
  
  List<Task> get todayTasks {
    final today = DateTime.now();
    return _tasks.where((task) {
      if (task.dueAt == null) return false;
      return task.dueAt!.day == today.day &&
             task.dueAt!.month == today.month &&
             task.dueAt!.year == today.year;
    }).toList();
  }

  void addTask(Task task) {
    _tasks.add(task);
    notifyListeners();
  }

  void updateTask(Task task) {
    final index = _tasks.indexWhere((t) => t.id == task.id);
    if (index != -1) {
      _tasks[index] = task;
      notifyListeners();
    }
  }

  void deleteTask(String taskId) {
    _tasks.removeWhere((task) => task.id == taskId);
    notifyListeners();
  }
}

class NoteProvider extends ChangeNotifier {
  List<Note> _notes = [];
  List<Note> get notes => _notes;

  void addNote(Note note) {
    _notes.add(note);
    notifyListeners();
  }

  void updateNote(Note note) {
    final index = _notes.indexWhere((n) => n.id == note.id);
    if (index != -1) {
      _notes[index] = note;
      notifyListeners();
    }
  }
}

class DeckProvider extends ChangeNotifier {
  List<Deck> _decks = [];
  List<Deck> get decks => _decks;

  void addDeck(Deck deck) {
    _decks.add(deck);
    notifyListeners();
  }

  void addCardToDeck(String deckId, FlashCard card) {
    final deck = _decks.firstWhere((d) => d.id == deckId);
    deck.cards.add(card);
    notifyListeners();
  }
}

class PetProvider extends ChangeNotifier {
  Pet _currentPet = Pet(
    userId: '',
    species: PetSpecies.cat,
  );
  int _currentStreak = 0;

  Pet get currentPet => _currentPet;
  int get currentStreak => _currentStreak;

  void addXP(int amount) {
    _currentPet = _currentPet.addXP(amount);
    notifyListeners();
  }

  void updateStreak(int streak) {
    _currentStreak = streak;
    notifyListeners();
  }
}

class SRSProvider extends ChangeNotifier {
  List<Review> _reviews = [];
  List<Review> get reviews => _reviews;

  List<Review> get dueReviews {
    final now = DateTime.now();
    return _reviews.where((r) => r.dueAt.isBefore(now)).toList();
  }

  void recordReview(FlashCard card, ReviewGrade grade) {
    final existingReview = _reviews.firstWhere(
      (r) => r.cardId == card.id,
      orElse: () => Review(
        cardId: card.id,
        userId: '', // From auth
        dueAt: DateTime.now(),
      ),
    );

    final updatedReview = existingReview.updateWithGrade(grade);
    
    final index = _reviews.indexWhere((r) => r.cardId == card.id);
    if (index != -1) {
      _reviews[index] = updatedReview;
    } else {
      _reviews.add(updatedReview);
    }
    
    notifyListeners();
  }
}

// Example pubspec.yaml dependencies needed:
/*
dependencies:
  flutter:
    sdk: flutter
  provider: ^6.0.5
  sqflite: ^2.3.0
  path_provider: ^2.1.1
  flutter_markdown: ^0.6.18
  shared_preferences: ^2.2.2
  uuid: ^4.2.1
  intl: ^0.18.1
  fl_chart: ^0.66.0
  
dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.1
*/